/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.agh.reactive;
import akka.Done;
import akka.NotUsed;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.javadsl.Behaviors;
import akka.japi.Pair;
import akka.stream.*;
import akka.stream.javadsl.*;
import edu.agh.reactive.greetings.GreeterMain;
import edu.agh.reactive.math.MathActor;
import scala.Int;


import javax.annotation.processing.Completion;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletionStage;

public class App {
  public static void main(String[] args) throws InterruptedException {

//    task2();
    task3();

  }

  public static void task2() {
    final ActorSystem streamSystem = ActorSystem.create(Behaviors.empty(), "streams");
    final Materializer materializer = Materializer.createMaterializer(streamSystem);

    final Source<Integer, NotUsed> source = Source.range(1, 100);
    final Flow<Integer, String, NotUsed> flow = Flow.fromFunction(Object::toString);
    final Flow<Integer, String, NotUsed> debugFlow = Flow.fromFunction((Integer n) -> {
      System.out.println("Value in debugFlow: " + n);
      return n.toString();
    });
    final Sink<String, CompletionStage<Done>> sink = Sink.foreach(System.out::println);
    final Sink<String, CompletionStage<Done>> slowSink = Sink.foreach(value -> {
      Thread.sleep(1000);
      System.out.println("Value in slowSink: " + value);
    });
    final RunnableGraph<NotUsed> runnableGraph = source
        .buffer(16, OverflowStrategy.dropHead()) // TODO: change strategy here
        .via(debugFlow).async().to(slowSink);
    runnableGraph.run(materializer);

    try {
      System.out.println(">>> Press ENTER to exit <<<");
      System.in.read();
    } catch (IOException ignored) {
    } finally {
      streamSystem.terminate();
    }
  }

  public static void task3() {
    final ActorSystem streamSystem = ActorSystem.create(Behaviors.empty(), "graph");
    final Materializer materializer = Materializer.createMaterializer(streamSystem);

    final Source<Integer, NotUsed> source = Source.range(1, 100);
    final Sink<String, CompletionStage<Done>> sink = Sink.foreach(System.out::println); // TODO
    final Flow<Integer, Integer, NotUsed> addOneFlow = Flow.fromFunction((Integer n) -> n + 1);
    final Flow<Integer, Integer, NotUsed> multiplyByTenFlow = Flow.fromFunction((Integer n) -> n * 10);
    final Flow<Integer, Integer, NotUsed> integerIdentityFlow = Flow.fromFunction((Integer n) -> n);
    final Flow<Pair<Integer, Integer>, String, NotUsed> stringifyPairFlow = Flow.fromFunction(
        (Pair<Integer, Integer> pair) -> pair.first().toString() + ", " + pair.second().toString()
    );

    RunnableGraph.fromGraph(
        GraphDSL.create(
            sink,
            (builder, out) -> {
              final UniformFanOutShape<Integer, Integer> broadcast = builder.add(Broadcast.create(2));
              final FanInShape2<Integer, Integer, Pair<Integer, Integer>> zipper = builder.add(Zip.create());

              final Outlet<Integer> dataSource = builder.add(source).out();

              // source to broadcast
              builder.from(dataSource).via(builder.add(integerIdentityFlow)).viaFanOut(broadcast);

              // broadcast to zipper
              builder.from(broadcast).via(builder.add(addOneFlow)).toInlet(zipper.in0());
              builder.from(broadcast).via(builder.add(multiplyByTenFlow)).toInlet(zipper.in1());

              // zipper to sink
              builder.from(zipper.out()).via(builder.add(stringifyPairFlow)).to(out);

              return ClosedShape.getInstance();
            }
        )
    ).run(materializer);

    try {
      System.out.println(">>> Press ENTER to exit <<<");
      System.in.read();
    } catch (IOException ignored) {
    } finally {
      streamSystem.terminate();
    }
  }
}
